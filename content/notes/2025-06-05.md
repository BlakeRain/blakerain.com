---
title: |
  Remapping memory regions on macOS
link: https://gist.github.com/BlakeRain/fce96e988b57e41fd650b33942b13071
date: 2025-06-05
---

I have recently had reason to reserve a large region of memory using `mmap`, and subsequently to
commit blocks of that memory, again using `mmap`. On Linux, this is straightforward:

```c
/* Reserve a large region of memory at a specific address */
mmap(addr, size, PROT_NONE, MAP_NORESERVE | MAP_ANON | MAP_PRIVATE, -1, 0);
madvise(addr, size, MADV_DONTNEED);

/* ... */

/* Commit a block of memory within the reserved region */
mmap(addr + offset, block_size, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
madvise(addr + offset, block_size, MADV_WILLNEED);
```

However, on macOS this has lead to a crash when the second `mmap` call is made. It seems that macOS
does not allow `mmap` to remap a memory region that has already been reserved. This caught me off
guard for a while, but rummaging through some old code I found a previous solution that seems to
work. Instead of using `mmap` to reserve and then commit memory, we use the macOS `vm_allocate` and
`vm_protect` functions from the Mach kernel API.

```c
kern_return_t kr = 0;
void *ret        = addr; /* The address to reserve */

/* Reserve a large region of memory at a specific address */
kr = vm_allocate(mach_task_self(), (vm_address_t *)&ret, size, VM_FLAGS_FIXED);
if (kr != KERN_SUCCESS) {
    /* If we failed to allocate, return NULL. */
    return NULL;
}

/* ... */

/* Commit a block of memory within the reserved region */
kr = vm_protect(mach_task_self(), (vm_address_t)ret, size, false, VM_PROT_READ | VM_PROT_WRITE);
if (kr != KERN_SUCCESS) {
    /* if we failed to commit, return NULL. */
    return NULL;
}
```

The above link is to a [Gist] that contains a more complete example from my current project.

[Gist]: https://gist.github.com/BlakeRain/fce96e988b57e41fd650b33942b13071
